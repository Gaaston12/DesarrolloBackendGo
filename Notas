FRAMEWORK VS LIBRER√çA

Framework: Ser√° la base sobre la cual podras construir y 
    desarrollar tu proyecto, incluye todas las herramientas 
    necesarias para completarlo (incluye librer√≠as, est√°ndares 
    y reglas).

Librer√≠a: Solo aborda una utilidad especifica, pudiendo agregar 
    m√°s de una en tu proyecto. Eso si, asegurate que no interfieran 
    con el c√≥digo de otra librer√≠a.

La uni√≥n entre el Frontend y el Backend se hace a trav√©s de una API:    Application Programming Interface.

Una API es una secci√≥n del backend que permite que el frontend pueda comunicarse con √©l a trav√©s de mensajes bidireccionales (de ida y vuelta).

Tenemos dos grandes est√°ndares para crear las APIs:

SOAP (Simple Objetct Access Protocol): Mueve la informaci√≥n a trav√©s de un lenguaje XML (Extensible Markup Language). Es similar al HTML, es un lenguaje demarcado. SOAP es un protocolo que ha quedado en el olvido.

<?xml version="1.0?>
<note>
    <to>Gaston</to>
    <from>Gas</from>
    <heading>Recordatorio</heading>
    <body>Saca la basura!</body>
</note>

Rest (Representational State Transfer): Utiliza otro lenguaje JSON (Javascript Objet Notation). Un JSON no es m√°s que un diccionario de Python. Los diccionarios de Python son lo mismo que los objetos de JS.
JSON.jpg

{
    "firstName": Gaston,
    "lastName": Martin,
    "isAlive": true,
    "addres":{
        "streetAddress": "Cabrera 642",
        "city": "Rio Cuarto"
    },
    "photneNumbers": [
        "type": "home",
        "number": "123"
    ]
}

T√©rminos hablados en la clase:

API ‚Äî> Application Programming Interface
SOAP ‚Äî> Simple Object Access Protocol
REST ‚Äî> Representational State Transfer
XML ‚Äî> Extensible Markup Language
JSON ‚Äî> JavaScript Object Notation

HTTP
Hypertext Transfer Protocol
Request
Cabezeras: piezas de informacion (Host, Accept-Language)
Metodos: GET, POST, PUT, DELETE
Responce
body: JSON o diccionarios
Header: Status Code, Server: aplicativo que permite distribuir, Date, Etag: hast, cahe, Accept-Rnages: como entregamos la info, Content-Length, Content-Type


HTTP nos permite transportar la informaci√≥n que viene de distintas formas: HTML, CSS,JS, webAPIs.
En la capa capa inferior se vale de protocolos como
IP: para identificar y comunicarse con el servidor
TCP, UDP: para la forma de envi√≥ de la informaci√≥n
TLS: hace la encriptaci√≥n de la informaci√≥n
DNS: resuelve los nombres de dominio a direcciones IP.

TCP - Son las siglas de Transmission Control Protocol, es un conjunto de reglas estandarizadas que permiten a los equipos comunicarse en una red como Internet.
**TLS **- Transport Layer Security, seguridad de la capa de transporte es el protocolo sucesor de SSL. Son protocolos criptogr√°ficos, que proporcionan comunicaciones seguras por una red, com√∫nmente Internet.‚Äã
**DNS **- El sistema de nombres de dominio (DNS) es el directorio telef√≥nico de Internet. Las personas acceden a la informaci√≥n en l√≠nea a trav√©s de nombres de dominio
**UDP **- El Protocolo de datagrama de usuario (UDP) es un protocolo ligero de transporte de datos que funciona sobre IP. UDP proporciona un mecanismo para detectar datos corruptos en paquetes, pero no intenta resolver otros problemas que surgen con paquetes, como cuando se pierden o llegan fuera de orden.

C√≥digos de estado de respuesta HTTP:
Respuestas informativas (100‚Äì199),
Respuestas satisfactorias (200‚Äì299),
Redirecciones (300‚Äì399),
Errores de los clientes (400‚Äì499),
y errores de los servidores (500‚Äì599).
100s: C√≥digos informativos que indican que la solicitud iniciada por el navegador contin√∫a.
200s: Los c√≥digos con √©xito regresaron cuando la solicitud del navegador fue recibida, entendida y procesada por el servidor.
300s: C√≥digos de redireccionamiento devueltos cuando un nuevo recurso ha sido sustituido por el recurso solicitado.
400s: C√≥digos de error del cliente que indican que hubo un problema con la solicitud.
500s: C√≥digos de error del servidor que indican que la solicitud fue aceptada, pero que un error en el servidor impidi√≥ que se cumpliera.


¬øC√≥mo es el flujo de desarrollo de una aplicaci√≥n web?
Entorno local (Editor de C√≥digo ‚Üí Git ‚Üí mi local) Pasar del entorno local al servidor se llama deploy.

Normalmente se hace un push a un repositorio remoto (Github), el cual es un servidor que solo contiene el c√≥digo de tu proyecto.

Cada vez que uno trae c√≥digo de Github a un entorno local es un pull.

Lo que se hace normalmente en un entorno profesional es CI/CD (Continuous Integration and Continuous Delivery) o Continous Deployment. Se prueba (testea), si funciona bien, el c√≥digo se va a al server (production).

El proyecto se guarda en production en un domain (dominio).
Se puede comprar un dominio, por ejemplo en namecheap.
En mi computadora, las cosas van a vivir en un entorno local:
Direcci√≥n y puerto, por ejemplo: 
    127.0.0.1 : 8000
        IP      Port



Curso de manejo de terminal
¬øQu√© es la terminal?

La terminal es una herramienta indispensable que cualquier persona en la tecnolog√≠a debe conocer üëÄ. Es importante porque:
Te da flexibilidad üìè. Con unos pocos comandos, puedes hacer mucho.
Es mucho m√°s veloz que una interfaz üíª.
Es tu √∫nica opci√≥n si no hay interfaz üòÜ, como para configurar un servidor remoto.
Puedes invocar demonios üëø. Hay que tener cuidado con los comandos.
Espec√≠ficamente, la terminal es una interfaz gr√°fica muy sencilla que simula una l√≠nea de comandos:
Terminal: Ventana que muestra el promt.
Shell (l√≠nea de comandos): Programa que ejecuta los comandos. Hay varios tipos de shell, pero sirven para lo mismo. La m√°s comunes son bash shell o Z shell. En este curso, usaremos la primera üçé.
Es importante comenzar a usar Linux üòü.
Un comando es un programa que se puede ejecutar desde la terminal.

Notas üòÑ
Aprendiendo a caminar en la terminal.

El sistema de archivos üìÅ inicia en un slash / y desciende a otras carpetas. De todas las carpetas, nos interesa home ya que dentro se encuentran las carpetas de cada usuario, donde est√°n todos los documentos.
Cuando entramos, la terminal nos coloca en ~, que es donde est√°n nuestros documentos /home/usuario.
cd Para acceder una carpeta, usa cd <carpeta>, para regresar a la carpeta anterior cd ... Para regresar a home, solo haz cd.
clear Para limpiar la pantalla, o bien, el comando ctrl+l.
En cada comando, hay varias especificaciones que podemos poner, despu√©s de -.
ls para listar archivos. Agrega -l o -lh para agregar detalles.
pwd print working directory üñ®Ô∏è.
file <archivo> sirve para describir un tipo de archivo y sus caracter√≠sticas ü•¥.

Como usualmente vamos y volvemos de diferentes directorios, pueden usar los comandos pushd y popd para hacerlo m√°s f√°cil.

El comando pushd mueve al nuevo directorio y guarda el actual en la pila.

El comando popd saca un directorio de la pila y te lleva all√°.

Mostrar informaci√≥n del directorio:
ls :Lista el contenido de los directorios (por defecto ordena la salida alfab√©ticamente).

Alguna de sus opciones (argumentos) m√°s √∫tiles son:

-a :todos los archivos, incluso los que comienzan con punto (.).

-A :Lista todos los ficheros en los directorios, excepto los que comienzan con punto . (.) y los que comienzan con doble punto (‚Ä¶).

-F :indica tipo: / directorio, * ejecutable, @ enlace simb√≥lico.

-h :indicar√° el tama√±o en KB, MB, etc.

-l :listado en formato largo (o detallado).

-S :clasifica los contenidos de los directorios por tama√±os, con los ficheros m√°s grandes en primer lugar.

-r :invierte el orden de la salida.

-R :Lista recursivamente los subdirectorios encontrados.

-t :ordenar por fecha de √∫ltima modificaci√≥n.

-u :ordenar por fecha de √∫ltimo acceso.

-x :presenta los ficheros por columnas.

-i :precede la salida con el n√∫mero de i-node

ejemplos:
ls -lt :muestra los archivos del mas actual al mas antiguo

ls -ltr :muestra los archivos del mas antiguo al mas actual

ls -lh :muestra de forma mas legible el tama√±o de los archivos

ls -lhS :muestra de forma ordenada los archivos por su tama√±o

ls -la :muestra los atributos de los archivos y los archivos ocultos

Explorando el contenido de nuestro archivos.

Podemos explorar el contenido de archivos sin la necesidad de abrirlos, desde la terminal üßê. Esto para archivos de texto.
head <documento de texto>: Nos muestra las primeras 10 l√≠neas de un archivo de texto. Para especificar el n√∫mero de l√≠neas head -n <numero de lineas> <archivo>
tail <documento>: Nos muestra las √∫ltimas 10 l√≠neas.
less <archivo>: Este es muy cool, es muy interactivo, nos permite hacer scroll, y nos permite hacer b√∫squedas haciendo /<palabra a buscar>. Para salir presionamos q üîç.
xdg-open <archivo>: Para abrir un archivo desde la terminal. Usa las aplicaciones predeterminadas. Esto para linux, para mac, es open. Esto crea un proceso en la terminal que no nos dejar√° hacer nada mas. Para terminar el proceso ctrl+c.
nautilus nos permite abrir el explorador de archivos en una posici√≥n dada (en linux) üìÅ.



Un comando puede ser 4 cosas:

Un programa ejecutable: que se compilo en algun lenguaje de programaci√≥n y se puede ejecutar

Un comando de utilidad de la shell.

Una funci√≥n de shell

Un alias

Comandos

type nos permite saber que clase es un comando. Por ejemplo type cd (es una funcion de shell), ls (es un alias)

Para crear un alias: alias ‚ÄònombreDelAlias‚Äô = ‚ÄòcomandoQueInvoca‚Äô. Por ejemploalias l=‚Äùls -lh‚Äù. Temporales, por el momento.

Con ‚Äìhelp o help, puedes tener una ayuda sobre los comandos.

man ‚Äòcomando‚Äô : hace referencia al manual de usuario de un comando, otro similar es inform√°tico

whatis ‚Äòcomando‚Äô : nos da una descripcion muy corta de que hace ese comando. Pero no funciona con todos.